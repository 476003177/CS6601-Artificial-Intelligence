# -*- coding: utf-8 -*-
"""
Created on Tue Sep 17 21:29:00 2019

@author: songl
"""

# coding=utf-8
import itertools
import pickle
import random
import unittest

import networkx

from explorable_graph import ExplorableGraph
from submission import a_star, bidirectional_a_star, \
    bidirectional_ucs, breadth_first_search, euclidean_dist_heuristic, \
    null_heuristic, haversine_dist_heuristic, tridirectional_search, tridirectional_upgraded, \
    uniform_cost_search, custom_heuristic


def is_valid(graph, path, start, goal):
    """
    Test whether a path is valid or not
    """
    if start == goal:
        return path == []
    else:
        if path[0] != start or path[-1] != goal:
            return False
    for i in range(len(path) -1):
        if path[i + 1] not in graph.neighbors(path[i]):
            return False
    return True

class SearchUnitTests(unittest.TestCase):
    def setUp(self):
        """Setup both atlanta and romania graph data."""

        with (open("romania_graph.pickle", "rb")) as romFile:
            romania = pickle.load(romFile)
        self.romania = ExplorableGraph(romania)
        self.romania.reset_search()

        with (open("atlanta_osm.pickle", "rb")) as atlFile:
            atlanta = pickle.load(atlFile)
        self.atlanta = ExplorableGraph(atlanta)
        self.atlanta.reset_search()

        self.margin_of_error = 1.0e-6

    def reference_path(self, graph, src_node, dst_node, weight='weight'):
        """
        Path as generated by networkx shortest path.

        Args:
            graph (ExplorableGraph): Undirected graph to search.
            src_node (node): Key for the start node.
            dst_node (node): Key for the end node.
            weight (:obj:`str`):
                If None, every edge has weight/distance/cost 1.
                If a string, use this edge attribute as the edge weight.
                Any edge attribute not present defaults to 1.

        Returns:
            Tuple with (cost of path, path as list).
        """

        graph.reset_search()
        path = networkx.shortest_path(graph, src_node, dst_node, weight=weight)
        cost = self.sum_weight(graph, path)

        return cost, path

    def reference_bfs_path(self, graph, src_node, dst_node):
        """
        Breadth First Search as generated by networkx shortest path.

        Args:
            graph (ExplorableGraph): Undirected graph to search.
            src_node (node): Key for the start node.
            dst_node (node): Key for the end node.

        Returns:

        """
        return self.reference_path(graph, src_node, dst_node, weight=None)

    @staticmethod
    def sum_weight(graph, path):
        """
        Calculate the total cost of a path by summing edge weights.

        Args:
            graph (ExplorableGraph): Graph that contains path.
            path (list(nodes)): List of nodes from src to dst.

        Returns:
            Sum of edge weights in path.
        """
        pairs = zip(path, path[1:])

        return sum([graph.get_edge_data(a, b)['weight'] for a, b in pairs])

    def run_romania_data(self, ref_method, method, **kwargs):
        """
        Run the test search against the Romania data.

        Args:
            ref_method (func): Reference search function to compare test search
            method (func): Test search function.
            kwargs: Keyword arguments.

        Asserts:
            True if the path from the test search is equivalent to the
            reference search.
        """

        keys = self.romania.node.keys()
        pairs = itertools.permutations(keys, 2)
        for src, dst in pairs:
            self.romania.reset_search()
            path = method(self.romania, src, dst, **kwargs)
            ref_len, ref_path = ref_method(self.romania, src, dst)

            if path != ref_path:
                print (src, dst)

            self.assertEqual(ref_path, path)

    def run_romania_tri(self, method, **kwargs):
        """
        Run the tridirectional test search against the Romania data.

        Args:
            method (func): Test search function.
            kwargs: Keyword arguments.

        Asserts:
            True if the path from the test search is equivalent to the
            reference search.
        """

        keys = self.romania.node.keys()
        triplets = itertools.permutations(keys, 3)
        for goals in triplets:
            self.romania.reset_search()
            path = method(self.romania, goals, **kwargs)
            path_len = self.sum_weight(self.romania, path)
            s1len, _ = self.reference_path(self.romania, goals[0], goals[1])
            s2len, _ = self.reference_path(self.romania, goals[2], goals[1])
            s3len, _ = self.reference_path(self.romania, goals[0], goals[2])
            min_len = min(s1len + s2len, s1len + s3len, s3len + s2len)

            if path_len != min_len:
                print (goals)

            self.assertEqual(min_len, path_len)
    
    def test_tri_ucs_romania(self):
        """Test Tri-UC search with Romania data."""

        self.run_romania_tri(tridirectional_search)
        
if __name__ == '__main__':
    unittest.main()